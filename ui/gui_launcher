# stealthmaster/ui/gui_launcher.py
"""
StealthMaster - GUI Launcher
Connects the Tkinter GUI to the main application.
"""

import asyncio
import threading
import logging
from pathlib import Path
from typing import Optional
import tkinter as tk
from tkinter import ttk, messagebox
import queue
from datetime import datetime

from ..config import Settings, load_settings
from ..main import StealthMaster

logger = logging.getLogger(__name__)


class StealthMasterGUI:
    """
    Enhanced GUI for StealthMaster
    Properly integrated with the main application.
    """
    
    def __init__(self, config_path: Path):
        """Initialize the GUI."""
        self.config_path = config_path
        self.settings = None
        self.app = None
        self.app_thread = None
        self.running = False
        
        # Communication queue
        self.event_queue = queue.Queue()
        
        # Create main window
        self.root = tk.Tk()
        self.root.title("StealthMaster - Control Panel")
        self.root.geometry("1200x800")
        
        # Set dark theme
        self.setup_theme()
        
        # Create UI
        self.create_ui()
        
        # Start event processor
        self.process_events()
        
        # Load configuration
        self.load_configuration()
    
    def setup_theme(self):
        """Setup dark theme."""
        self.root.configure(bg='#1a1a1a')
        
        # Style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Configure dark theme
        style.configure('TFrame', background='#1a1a1a')
        style.configure('TLabel', background='#1a1a1a', foreground='#ffffff')
        style.configure('TButton', background='#2d2d2d', foreground='#ffffff')
        style.map('TButton',
                  background=[('active', '#3d3d3d'), ('pressed', '#4d4d4d')])
    
    def create_ui(self):
        """Create the user interface."""
        # Create notebook for tabs
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Dashboard tab
        self.dashboard_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.dashboard_frame, text="üìä Dashboard")
        self.create_dashboard()
        
        # Monitoring tab
        self.monitoring_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.monitoring_frame, text="üîç Monitoring")
        self.create_monitoring()
        
        # Configuration tab
        self.config_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.config_frame, text="‚öôÔ∏è Configuration")
        self.create_configuration()
        
        # Logs tab
        self.logs_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.logs_frame, text="üìú Logs")
        self.create_logs()
        
        # Control panel at bottom
        self.create_control_panel()
    
    def create_dashboard(self):
        """Create dashboard tab."""
        # Stats frame
        stats_frame = ttk.LabelFrame(self.dashboard_frame, text="Live Statistics")
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create stat labels
        self.stat_labels = {}
        stats = [
            ("monitors_active", "Active Monitors", "üîç"),
            ("strikes_attempted", "Strike Attempts", "‚ö°"),
            ("strikes_successful", "Successful Strikes", "‚úÖ"),
            ("detections_encountered", "Detections", "üö®"),
            ("detections_bypassed", "Bypassed", "üõ°Ô∏è"),
            ("tickets_found", "Tickets Found", "üé´"),
            ("data_used_mb", "Data Used (MB)", "üìä"),
        ]
        
        for i, (key, label, icon) in enumerate(stats):
            frame = ttk.Frame(stats_frame)
            frame.grid(row=i//2, column=i%2, padx=20, pady=10, sticky="ew")
            
            ttk.Label(frame, text=f"{icon} {label}:", 
                     font=('Arial', 12)).pack(side=tk.LEFT)
            
            value_label = ttk.Label(frame, text="0", 
                                   font=('Arial', 12, 'bold'))
            value_label.pack(side=tk.RIGHT)
            
            self.stat_labels[key] = value_label
        
        # Browser pool status
        pool_frame = ttk.LabelFrame(self.dashboard_frame, text="Browser Pool")
        pool_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.pool_label = ttk.Label(pool_frame, text="Not initialized", 
                                   font=('Arial', 11))
        self.pool_label.pack(pady=10)
    
    def create_monitoring(self):
        """Create monitoring tab."""
        # Detection events
        events_frame = ttk.LabelFrame(self.monitoring_frame, text="Detection Events")
        events_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create treeview for events
        columns = ('Time', 'Type', 'URL', 'Confidence', 'Status')
        self.events_tree = ttk.Treeview(events_frame, columns=columns, 
                                       show='tree headings', height=15)
        
        for col in columns:
            self.events_tree.heading(col, text=col)
            self.events_tree.column(col, width=150)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(events_frame, orient=tk.VERTICAL, 
                                 command=self.events_tree.yview)
        self.events_tree.configure(yscrollcommand=scrollbar.set)
        
        self.events_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def create_configuration(self):
        """Create configuration tab."""
        # Mode selection
        mode_frame = ttk.LabelFrame(self.config_frame, text="Operation Mode")
        mode_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.mode_var = tk.StringVar(value="stealth")
        modes = [
            ("stealth", "ü•∑ Stealth - Balanced stealth and performance"),
            ("ultra_stealth", "üõ°Ô∏è Ultra Stealth - Maximum protection"),
            ("beast", "üöÄ Beast - Maximum speed, lower stealth"),
            ("adaptive", "üß† Adaptive - AI-driven mode switching"),
        ]
        
        for value, text in modes:
            ttk.Radiobutton(mode_frame, text=text, variable=self.mode_var, 
                           value=value).pack(anchor=tk.W, padx=20, pady=5)
        
        # Proxy settings
        proxy_frame = ttk.LabelFrame(self.config_frame, text="Proxy Settings")
        proxy_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.proxy_enabled = tk.BooleanVar(value=True)
        ttk.Checkbutton(proxy_frame, text="Enable Proxy", 
                       variable=self.proxy_enabled).pack(anchor=tk.W, padx=20, pady=5)
        
        # Data optimization
        data_frame = ttk.LabelFrame(self.config_frame, text="Data Optimization")
        data_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.block_images = tk.BooleanVar(value=True)
        self.block_fonts = tk.BooleanVar(value=True)
        
        ttk.Checkbutton(data_frame, text="Block Images", 
                       variable=self.block_images).pack(anchor=tk.W, padx=20, pady=5)
        ttk.Checkbutton(data_frame, text="Block Fonts", 
                       variable=self.block_fonts).pack(anchor=tk.W, padx=20, pady=5)
    
    def create_logs(self):
        """Create logs tab."""
        # Log display
        self.log_text = tk.Text(self.logs_frame, wrap=tk.WORD, 
                               bg='#0d0d0d', fg='#00ff00',
                               font=('Consolas', 10))
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(self.log_text, orient=tk.VERTICAL,
                                 command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Tags for colored text
        self.log_text.tag_configure('info', foreground='#00ff00')
        self.log_text.tag_configure('warning', foreground='#ffff00')
        self.log_text.tag_configure('error', foreground='#ff0000')
        self.log_text.tag_configure('success', foreground='#00ffff')
    
    def create_control_panel(self):
        """Create control panel."""
        control_frame = ttk.Frame(self.root)
        control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Start/Stop button
        self.start_button = ttk.Button(control_frame, text="‚ñ∂Ô∏è Start Bot",
                                      command=self.toggle_bot)
        self.start_button.pack(side=tk.LEFT, padx=5)
        
        # Status label
        self.status_label = ttk.Label(control_frame, text="‚ö™ Stopped",
                                     font=('Arial', 12, 'bold'))
        self.status_label.pack(side=tk.LEFT, padx=20)
        
        # Emergency stop
        ttk.Button(control_frame, text="üõë Emergency Stop",
                  command=self.emergency_stop).pack(side=tk.RIGHT, padx=5)
    
    def load_configuration(self):
        """Load configuration file."""
        try:
            self.settings = load_settings(self.config_path)
            self.log_event("Configuration loaded successfully", "success")
            
            # Update UI with settings
            self.mode_var.set(self.settings.app_settings.mode.value)
            self.proxy_enabled.set(self.settings.proxy_settings.enabled)
            self.block_images.set(self.settings.browser_options.block_images)
            
        except Exception as e:
            self.log_event(f"Failed to load configuration: {e}", "error")
            messagebox.showerror("Configuration Error", 
                               f"Failed to load configuration:\n{e}")
    
    def toggle_bot(self):
        """Start or stop the bot."""
        if not self.running:
            self.start_bot()
        else:
            self.stop_bot()
    
    def start_bot(self):
        """Start the bot."""
        try:
            # Update settings with UI values
            self.settings.app_settings.mode = self.mode_var.get()
            self.settings.proxy_settings.enabled = self.proxy_enabled.get()
            self.settings.browser_options.block_images = self.block_images.get()
            
            # Create app instance
            self.app = StealthMaster(self.settings)
            
            # Setup event forwarding
            self.setup_event_forwarding()
            
            # Start in separate thread
            self.app_thread = threading.Thread(target=self.run_bot_async)
            self.app_thread.daemon = True
            self.app_thread.start()
            
            # Update UI
            self.running = True
            self.start_button.configure(text="‚è∏Ô∏è Stop Bot")
            self.status_label.configure(text="üü¢ Running")
            
            self.log_event("Bot started successfully", "success")
            
        except Exception as e:
            self.log_event(f"Failed to start bot: {e}", "error")
            messagebox.showerror("Start Error", f"Failed to start bot:\n{e}")
    
    def stop_bot(self):
        """Stop the bot."""
        if self.app:
            self.app.running = False
            
            # Update UI
            self.running = False
            self.start_button.configure(text="‚ñ∂Ô∏è Start Bot")
            self.status_label.configure(text="üü° Stopping...")
            
            self.log_event("Stopping bot...", "warning")
    
    def emergency_stop(self):
        """Emergency stop."""
        if messagebox.askyesno("Emergency Stop", 
                              "Are you sure you want to perform an emergency stop?"):
            if self.app:
                self.app.running = False
            
            self.running = False
            self.start_button.configure(text="‚ñ∂Ô∏è Start Bot")
            self.status_label.configure(text="üî¥ Emergency Stop")
            
            self.log_event("EMERGENCY STOP ACTIVATED", "error")
    
    def setup_event_forwarding(self):
        """Setup event forwarding from app to GUI."""
        # Override app's log method to forward to GUI
        original_log = self.app._log_event
        
        def forwarded_log(message, level="info"):
            original_log(message, level)
            self.event_queue.put(("log", message, level))
        
        self.app._log_event = forwarded_log
        
        # Setup stats update timer
        def update_stats():
            while self.app and self.app.running:
                stats = self.app.stats.copy()
                pool_stats = self.app.browser_pool.get_pool_stats()
                self.event_queue.put(("stats", stats, pool_stats))
                threading.Event().wait(1)
        
        stats_thread = threading.Thread(target=update_stats)
        stats_thread.daemon = True
        stats_thread.start()
    
    def run_bot_async(self):
        """Run bot in async context."""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            loop.run_until_complete(self.run_bot())
        except Exception as e:
            self.event_queue.put(("error", str(e), None))
        finally:
            loop.close()
            
            # Update UI when stopped
            self.event_queue.put(("stopped", None, None))
    
    async def run_bot(self):
        """Run the bot."""
        try:
            await self.app.initialize()
            await self.app.run()
        finally:
            await self.app.shutdown()
    
    def process_events(self):
        """Process events from the queue."""
        try:
            while True:
                try:
                    event_type, data, extra = self.event_queue.get_nowait()
                    
                    if event_type == "log":
                        self.log_event(data, extra)
                    
                    elif event_type == "stats":
                        self.update_stats(data, extra)
                    
                    elif event_type == "detection":
                        self.add_detection_event(data)
                    
                    elif event_type == "error":
                        self.log_event(f"Error: {data}", "error")
                        messagebox.showerror("Bot Error", data)
                    
                    elif event_type == "stopped":
                        self.status_label.configure(text="‚ö™ Stopped")
                        self.start_button.configure(text="‚ñ∂Ô∏è Start Bot")
                        self.running = False
                    
                except queue.Empty:
                    break
        except Exception as e:
            logger.error(f"Event processing error: {e}")
        
        # Schedule next check
        self.root.after(100, self.process_events)
    
    def log_event(self, message: str, level: str = "info"):
        """Add event to log display."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        self.log_text.insert(tk.END, f"[{timestamp}] ", 'timestamp')
        self.log_text.insert(tk.END, f"{message}\n", level)
        
        # Auto-scroll
        self.log_text.see(tk.END)
        
        # Limit log size
        if int(self.log_text.index('end-1c').split('.')[0]) > 1000:
            self.log_text.delete('1.0', '2.0')
    
    def update_stats(self, stats: dict, pool_stats: dict):
        """Update statistics display."""
        # Update stat labels
        for key, label in self.stat_labels.items():
            value = stats.get(key, 0)
            
            if key == "data_used_mb":
                label.configure(text=f"{value:.1f}")
            else:
                label.configure(text=str(value))
        
        # Update pool status
        pool_text = (
            f"Total: {pool_stats['total']} | "
            f"Idle: {pool_stats['idle']} | "
            f"Busy: {pool_stats['busy']} | "
            f"Crashed: {pool_stats['crashed']}"
        )
        self.pool_label.configure(text=pool_text)
    
    def add_detection_event(self, event: dict):
        """Add detection event to monitoring tab."""
        self.events_tree.insert('', 0, values=(
            event['timestamp'].strftime("%H:%M:%S"),
            event['type'],
            event['url'][:50] + "...",
            f"{event['confidence']:.2f}",
            event['status']
        ))
        
        # Limit entries
        if len(self.events_tree.get_children()) > 100:
            self.events_tree.delete(self.events_tree.get_children()[-1])
    
    def run(self):
        """Run the GUI."""
        self.root.mainloop()


def launch_gui(config_path: Path):
    """Launch the GUI interface."""
    gui = StealthMasterGUI(config_path)
    gui.run()